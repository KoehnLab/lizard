// This file is part of the lizard quantum chemistry software.
// Use of this source code is governed by a BSD-style license that
// can be found in the LICENSE file at the root of the lizard source
// tree or at <https://github.com/KoehnLab/lizard/blob/main/LICENSE>.

#include "SymmetryUtils.hpp"

#include "lizard/process/ProcessingException.hpp"

#include <fmt/core.h>

using namespace perm;

namespace lizard {

using CycleVal = perm::Cycle::value_type;

auto makeAntisymmetricExchanges(nonstd::span< const std::size_t > elementPositions) -> PrimitivePermutationGroup {
	PrimitivePermutationGroup group;

	// The overall symmetry is generated by all pairwise, antisymmetric exchanges of elements in the range
	for (std::size_t i = 0; i < elementPositions.size(); ++i) {
		for (std::size_t j = i + 1; j < elementPositions.size(); ++j) {
			group.addGenerator(ExplicitPermutation(
				Cycle({ static_cast< CycleVal >(elementPositions[i]), static_cast< CycleVal >(elementPositions[j]) }),
				-1));
		}
	}

	return group;
}

auto makeDiscontinousAntisymmetricRanges(const std::vector< nonstd::span< const std::size_t > > &ranges)
	-> PrimitivePermutationGroup {
	PrimitivePermutationGroup group;

	for (const nonstd::span< const std::size_t > &currentRange : ranges) {
		for (std::size_t i = 0; i < currentRange.size(); ++i) {
			for (std::size_t j = i + 1; j < currentRange.size(); ++j) {
				group.addGenerator(ExplicitPermutation(
					Cycle({ static_cast< CycleVal >(currentRange[i]), static_cast< CycleVal >(currentRange[j]) }), -1));
			}
		}
	}

	return group;
}

auto makeColumnsymmetricExchanges(nonstd::span< const std::size_t > firstGroup,
								  nonstd::span< const std::size_t > secondGroup) -> PrimitivePermutationGroup {
	if (firstGroup.size() != secondGroup.size()) {
		throw ProcessingException(
			fmt::format("Can't create column-symmetric exchanges for two groups of differing sizes ({} and {})",
						firstGroup.size(), secondGroup.size()));
	}

	std::size_t groupSize = firstGroup.size();

	PrimitivePermutationGroup group;

	// The column symmetry is generated by all pairwise exchanges in the first group where each of these
	// is accompanied by a simultaneous and equivalent exchange in the second group.
	// So if we exchange element 0 and 1 in the first group, we have to simultaneously exchange elements
	// 0 and 1 in the second group.
	for (std::size_t i = 0; i < groupSize; ++i) {
		for (std::size_t j = i + 1; j < groupSize; ++j) {
			group.addGenerator(ExplicitPermutation(
				Cycle({ { static_cast< CycleVal >(firstGroup[i]), static_cast< CycleVal >(firstGroup[j]) },
						{ static_cast< CycleVal >(secondGroup[i]), static_cast< CycleVal >(secondGroup[j]) } })));
		}
	}

	return group;
}

auto containsAntisymmetryOf(const perm::AbstractPermutationGroup &symmetry, nonstd::span< const std::size_t > positions)
	-> bool {
	// Check if the symmetry contains all generators of antisymmetric exchanges of the elements within positions
	for (std::size_t i = 0; i < positions.size(); ++i) {
		for (std::size_t j = i + 1; j < positions.size(); ++j) {
			ExplicitPermutation generator(
				Cycle({ static_cast< CycleVal >(positions[i]), static_cast< CycleVal >(positions[j]) }), -1);

			if (!symmetry.contains(generator)) {
				return false;
			}
		}
	}

	return true;
}

} // namespace lizard
